// ========================================================
// START: interface declarations


// ----------------------------------------------
// START: action interfaces

export interface IAction {
  type: string,
  payload: IPayload,
  error?: boolean,
  meta?: {
    dispatched?: boolean
  }
}

export interface IActionError extends IAction {
  type: string,
  payload: IPayloadError
}

export interface IActionStamped extends IAction {
  type: string,
  payload: IPayloadStamped
}

//  END: action interfaces
// ----------------------------------------------
// START: config (Redux) slice interface

export interface IConfigDefault {
  allowNegative: boolean,
  endMode: END_MODE,
  minScore?: number,
  maxScore?: number,
  name?: string,
  playOrder: PLAY_ORDER,
  trackTime: boolean
}

export interface IConfigGame {
  allowNegative: boolean,
  endMode: END_MODE,
  minScore?: number,
  maxScore?: number,
  name: string,
  playOrder: PLAY_ORDER,
  trackTime: boolean
}

//  END:  config (Redux) slice interfaces
// ----------------------------------------------
// START: game (Redux) slice intefaces

/**
 * record of a game
 *
 * @property end     Timestamp for when the game ended
 * @property config  configuration information for the game
 * @property pause   information about the "pause" state of
 *                   the game
 * @property players information about the players playing
 *                   the current game
 * @property results final status of the game.
 * @property round   information about the current round of
 *                   turns being played
 * @property scores  list of all the Turns taken so far in
 *                   the game in order of play
 * @property start   Timestamp for when the game started
 */
export interface IGame {
  end: number,
  config: IConfigGame,
  pause: IPause,
  players: IPlayers,
  results?: IPlayerResult[],
  round?: IRound,
  scores: ITurnComplete[],
  start: number
}

/**
 * Games have rounds so an active game requires an IRound
 * property to store info about the round currently being
 * played
 *
 * @property round all the info needed to manage the current
 *                 round of play
 */
export interface IGameActive {
  end: number,
  config: IConfigGame,
  pause: IPause,
  players: IPlayers,
  round: IRound,
  scores: ITurnComplete[],
  start: number,
}

export interface IGameFinished {
  end: number,
  config: IConfigGame,
  pause: IPause,
  players: IPlayers,
  results: IPlayerResult[],
  scores: ITurnComplete[],
  start: number
}


//  END:  game (Redux) slice intefaces
// ----------------------------------------------
// START: pause intefaces


/**
 * Pause slice of game interface
 *
 * @property start          When the current pause period
 *                          started
 * @property end            when the current pause period
 *                          ended
 * @property isPaused       Whether or not the game is
 *                          currently paused
 * @property totalPauseTime the total amount of time the
 *                          game has been paused so far
 * @property log            list of all pause events so far
 */
export interface IPause {
  start: number,
  end: number,
  isPaused: boolean,
  pauses: number[],
  totalPauseTime: number,
  log: Array<IPauseLog|IPauseFailLog>
}

/**
 * Log entry generated each time the game is paused or
 * resumed
 *
 * @property message [optional] infomation about why the
 *                   game was paused or resumed
 * @property time    timestamp for when the game was paused
 *                   or resumed
 * @property type    either 'Pause' or 'Resume'
 */
export interface IPauseLog {
  message?: string,
  time: number,
  mode: PAUSE_LOG_TYPE
  error: boolean,
}

/**
 * Log entry generated each time the game is paused or
 * resumed
 *
 * @property message [optional] infomation about why the
 *                   game was paused or resumed
 * @property time    timestamp for when the game was paused
 *                   or resumed
 * @property type    either 'Pause' or 'Resume'
 */
export interface IPauseFailLog extends IPauseLog {
  message: string,
  time: number,
  mode: PAUSE_LOG_TYPE
  error: boolean
}

//  END:  pause interfaces
// ----------------------------------------------
// START: payload intefaces

/**
 * Generic payload objec contains all the possible properties
 * that might be required for every action
 *
 */
export interface IPayload {
  action?: IAction,
  dispatched?: boolean,
  id?: number,
  isPaused?: boolean,
  now?: number,
  message?: string,
  name?: string,
  pausedSeconds?: number,
  position?: number
  playOrder?: PLAY_ORDER,
  playersSeated?: IPlayerSimple[]
  score?: number,
  state?: object,
  totalScore?: number,
  turn?: ITurnComplete,
  turns?: ITurnComplete[],
}

/**
 * Error payload is generated by middleware when it finds
 * something it doesn't like or understand
 *
 * @property message human readable description of error
 * @property code    UID of error type
 * @property state   slice of state (at the time error was
 *                   generated) that the action was trying
 *                   to effect
 * @property action  the original action that was trying to
 *                   effect the state
 */
export interface IPayloadError extends IPayloadStamped {
  now: number,
  message: string,
  code: number,
  state: object,
  action: IAction
}

/**
 * All actions get a timestamp applied to them (by middleware)
 * before they are dispatched to the store
 *
 * @property now timestam for when the action first hits
 *               the store
 */
export interface IPayloadStamped extends IPayload {
  now: number
}

//  END:  payload interfaces
// ----------------------------------------------
// START: player(s) intefaces


/**
 * IPlayer object are used for tracking statistical
 * information about a player in the current game
 *
 * @property position   Seating positing at the start of
 *                      the game
 * @property rank       Overall rank in the game
 * @property score      Total score (accumulation of score
 *                      from all turns played so far)
 * @property timePaused Total number of seconds the player
 *                      has been paused for during the game
 * @property timePlayed Total number of seconds the player
 *                      has taken for all their turns
 *                      combined (includes paused time)
 * @property turns      The number of turns the play has
 *                      played so far
 */
export interface IPlayer extends IPlayerSimple {
  position: number,
  rank: number,
  score: number,
  timePaused: number,
  timePlayed: number
  turns: number,
}

export interface IPlayerSimple {
  id: number,
  name: string,
}

export interface IPlayerResult extends IPlayerSimple{
  score: number,
  rank: number
}

export interface IPlayers {
  index: number,
  all: IPlayer[],
  playersSeatOrder: IPlayerSimple[]
  finalResult?: ITurnComplete[]
  // playerPositions: number[]
}

export interface IPlayersAll {
  index: number,
  players: IPlayerSimple[]
}

//  END:  player(s) interfaces
// ----------------------------------------------


/**
 * @property index          the UID for the next round to
 *                          be played
 * @property turns          object containing the turns
 *                          played for this round in the
 *                          game
 * @property playersInOrder list of players yet to have
 *                          their turns
 * @property winnerID       UID of the winner of the round
 * @property leaderID       UID overall game leader
 */
export interface IRound {
  index: number,
  turns: IRoundTurns,
  playersInOrder: IPlayerSimple[],
  winnerID?: number,
  leaderID?: number
}

/**
 * @property index   UID (for this game) for the next turn
 *                   to be created
 * @property current Turn object for the current player
 * @property played  Array of completed turns
 */
export interface IRoundTurns {
  index: number,
  current: ITurn,
  played: ITurnComplete[]
}

// ----------------------------------------------
// START: turn interfaces

export interface ITurn {
  id: number,
  playerID: number,
  playOrder: number,
  start: number,
  pauseDuration: number
  end?: number,
  score: {
    round: number,
    total?: number
  }
}

/**
 * ITurnComplete represents a finalised turn that has been ranked and stored
 * in the scores array it should be immutable
 */
export interface ITurnComplete extends ITurn {
  id: number,
  roundIndex: number,
  playerID: number,
  playOrder: number,
  start: number,
  end: number,
  score: ITurnScore,
  pauseDuration: number,
  rank: ITurnRank
}

export interface ITurnScore {
  round: number,
  total?: number
}

export interface ITurnRank {
  round: number,
  overall: number
}

//  END:  turn interfaces
// ----------------------------------------------


export interface IWholeScored {
  allPlayers: IPlayersAll,
  defaultConfig: IConfigDefault
  currentGame: IGameActive,
  pastGames: IGameFinished[],
}


//  END:  interface declarations
// ========================================================
// START: unions declarations

export type SliceTypes = IConfigDefault | IConfigGame | IGame |
                         IGame[] | IPause | IPlayers | IPlayersAll |
                         IRound | IRoundTurns | ITurnComplete[] |
                         ITurnRank | ITurnScore | number

//  END:  unions declarations
// ========================================================
// START: function interfaces


export interface ICompare {
  (a : any, b: any) : number
}

export interface IGetTurns {
  (
    allScores: ITurnComplete[],
    id: number,
    sortedBy : SCORE_SORT_METHOD
  ) : ITurnComplete[]
}

export interface Reducer {
  (state : SliceTypes, action : IAction) : SliceTypes
}


//  END:  function interfaces
// ========================================================
// START: enum declarations


export enum END_MODE {
  CURRENT_PLAYER = 'Current player',
  END_ROUND = 'End of current round',
  MIN_MAX_SCORE = 'Min/Max score'
}

/**
 * Play order defines who the first player will be at the start of
 * each round
 *
 * @const {object}
 */
export enum PLAY_ORDER {
  SEATING_POSTION = 'Seating position',
  ROUND_WINNER = 'Round winner',
  TRICK = 'Trick',
  GAME_LEADER = 'Game leader',
  NEXT = 'Next player'
}

export enum PAUSE_ACTION {
  start,
  end
}

export enum SCORE_SORT_METHOD {
  order,
  round,
  total
}

export enum FILTER_BY_PROP {
  id,
  playerID
}

export enum PAUSE_LOG_TYPE {
  PAUSE,
  RESUME
}
